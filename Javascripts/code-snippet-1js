// Find the output and explain:


1. [] == ![]

console.log([] == ![])

// Output: true

// Note:evaluates to true, and this can seem very confusing at first glance. 
// But this happens due to type coercion in JavaScript. Let's break it down step by step:

  -  Step 1: Evaluate ![]
            -  [] (an empty array) is a truthy value.
            
            -  ![] is negation, so it becomes:     ![] === false

            - So, now the expression becomes:   [] == false

  -  Step 2: Type Coercion in == (loose equality)


          -  JavaScript's == operator performs type coercion when comparing values of different types.

          - So, for the expression :    [] == false
        
              - When you compare an object (like an array) to a boolean, here's what happens:

                    -  Rule:
                        -  If one side is an object and the other is a primitive:
                        
                        -  JavaScript tries to convert the object to a primitive (string or number) via .toString() or .valueOf().

          -  So, now the expression become as this:     [] == false â†’â†’â†’â†’â†’â†’â†’â†’â†’ '' == false     (because [].toString() â†’ '')

          - Now, the expression becomes: '' == false

    -   Final Step: Coercion Again ('' == false)

          Now, we compare a string to a boolean.
          
          JavaScript converts both sides to numbers:
          
         i.e   Number('') â†’ 0
               Number(false) â†’ 0

    - So, 0 == 0 â†’ true âœ…


NOTE SHORT CUT:

[] â†’ ![]  ==>    [] == false    ==>  '' == false      ==>  0 == 0  ==> TRUE




// *****************************************************************************************************
          


2. null == undefined 

null == undefined // true
null === undefined // false

// ğŸ’¡ Note: Loose equality (==) treats null and undefined as equal. Strict equality (===) does not.





// *****************************************************************************************************

3. NaN === NaN

console.log(NaN == NaN); // âŒ false

or 

console.log(NaN === NaN); // âŒ false



Why?
NaN is not equal to anything, even itself!
Use Number.isNaN() to check for it.




// *****************************************************************************************************


  4. [] + []

  console.log([] + []); // ''

Note:

Empty arrays get coerced to empty strings:  [].toString() ===> ''

So:    '' + '' â†’ ''


// *****************************************************************************************************


5. [] + {} vs. {} + []:


console.log([] + {});  // '[object Object]'
console.log({} + []);  // 0


Why?

[] + {} â†’ '' + '[object Object]' â†’ '[object Object]'

{} + [] is parsed as a block ({}) followed by +[] â†’ 0


// *****************************************************************************************************



6. typeof null


console.log(typeof null); // 'object' âŒ

Why?
A historical JavaScript bug â€” null is not an object, but typeof null incorrectly returns 'object'.



// *****************************************************************************************************


  7. '5' - 2 vs '5' + 2


console.log('5' - 2); // 3 âœ…
console.log('5' + 2); // '52' âŒ



Why?

- forces numeric coercion.

+ prefers string concatenation if one operand is a string.



// *****************************************************************************************************

  8. false == '0'


console.log(false == '0'); // âœ… true


Note: 

=> false â†’ 0
=> '0' â†’ 0

So, 0 == 0 â†’ true



// *****************************************************************************************************


9. true + true

console.log(true + true); // 2 âœ…

Note: 
Booleans convert to numbers:

true â†’ 1

So, 1 + 1 â†’ 2


// *****************************************************************************************************


10. parseInt('08') vs parseInt('08', 10)


onsole.log(parseInt('08'));     // 0 âŒ (in old browsers, parsed as octal)
console.log(parseInt('08', 10)); // 8 âœ…

Why?
Without radix, older JS engines treated '08' as octal (invalid digit â†’ 0). Always specify radix.


  
// *****************************************************************************************************
  
  

11. [1, 2, 3] == '1,2,3'

console.log([1,2,3] == '1,2,3'); // âœ… true

Why?
Array is coerced to string:


[1,2,3].toString() â†’ '1,2,3'

So, '1,2,3' == '1,2,3' â†’ true


  
// *****************************************************************************************************

  


