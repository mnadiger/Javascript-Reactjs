const obj = {
  a: 1,
  b: 2,
  sum() {
    return this.a + this.b
  }
}

consr result = obj.sum;
console.log(result());


Output: NaN

Why?


üß† Step-by-step Explanation:

1. Object definition:

    const obj = {
      a: 1,
      b: 2,
      sum() { return this.a + this.b }
    };


‚úÖ Here, sum is defined as a method of obj.

When you call it as obj.sum(), the this inside the function refers to obj.

So:

obj.sum(); // returns 3 (1 + 2)



2. Assigning the method to a variable:

const result = obj.sum;


Now, you are not calling sum().
You are just copying the function reference to a standalone variable result.

At this point:

result === obj.sum  // true (same function reference)


BUT ‚Äî now result is not bound to obj anymore.
So, when you later call:

result();


"this" inside that function is no longer obj.



‚öôÔ∏è 3. What is "this" inside result()?


That depends on how the function is called.

In strict mode, this is undefined.

In non-strict mode, this refers to the global object (window in browsers, global in Node.js).

So inside sum():

this.a  // undefined (since 'this' is not 'obj')
this.b  // undefined


Hence:

this.a + this.b  // results in NaN (undefined + undefined)



‚ö° 4. Output

If you log the variable directly:

console.log(result);


You‚Äôll see:

∆í sum() {
  return this.a + this.b;
}


‚úÖ Because console.log(result) just prints the function definition, not the result of executing it.

If you had written:

console.log(result());


Then you‚Äôd get:

NaN

‚úÖ Summary:

Expression	              Meaning	                                                  Output:
___________________________________________________________________________________________________
obj.sum()	              Called as a method ‚Üí this = obj	                             3
result = obj.sum	      Copying function (no this binding)	                         ‚Äî
result()	              Called standalone ‚Üí this = undefined or window	             NaN
